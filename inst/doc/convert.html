<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Heuristic time conversion</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>tsbox relies on a set of converters to convert time series stored as <code>ts</code>,
<code>xts</code>, <code>data.frame</code>, <code>data.table</code> or <code>tibble</code> to each other. This vignette
describes some background on two particular challenges, the conversion of
<em>equispaced points in time</em> to <em>actual dates or times</em>, and the <em>regularization 
of irregular time sequences</em>.</p>

<p>The classic way of storing time series in R in <code>&quot;ts&quot;</code> objects. These are simple
vectors with an attribute that describes the beginning of the series, the
(redundant) end, and the frequency. Thus, a monthly series, e.g.,
<code>AirPassengers</code>, is defined as a numeric vector that starts in 1949, with
frequency 1. Thus, months are thought of as equispaced periods with a length of 
exactly 1/12 of a year.</p>

<p>For most time series, this is not what is meant. The second period of
<code>AirPassengers</code>, February 1949, is actually shorter than the first one, but this
is not reflected in the <code>&quot;ts&quot;</code> object. When converting to classes with actual
time stamps, tsbox tries to correct it by using <strong>heuristic</strong>, rather than
<strong>exact</strong> time conversion if possible.</p>

<h2>Heuristic time conversion</h2>

<p>Whenever possible, tsbox relies on <strong>heuristic time conversion</strong>. When a monthly
<code>&quot;ts&quot;</code> time series, e.g., <code>AirPassengers</code>, is converted to a data frame, each
time stamp (of class <code>&quot;Date&quot;</code>) indicates the first day of the month.
Heuristic conversion is done for the following frequencies:</p>

<table><thead>
<tr>
<th><code>ts</code>-frequency</th>
<th>time difference</th>
</tr>
</thead><tbody>
<tr>
<td>365.2425</td>
<td>1 day</td>
</tr>
<tr>
<td>12</td>
<td>1 month</td>
</tr>
<tr>
<td>6</td>
<td>2 month</td>
</tr>
<tr>
<td>4</td>
<td>3 month</td>
</tr>
<tr>
<td>3</td>
<td>4 month</td>
</tr>
<tr>
<td>2</td>
<td>6 month</td>
</tr>
<tr>
<td>1</td>
<td>1 year</td>
</tr>
<tr>
<td>0.5</td>
<td>2 year</td>
</tr>
<tr>
<td>0.333</td>
<td>3 year</td>
</tr>
<tr>
<td>0.25</td>
<td>4 year</td>
</tr>
<tr>
<td>0.2</td>
<td>5 year</td>
</tr>
<tr>
<td>0.1</td>
<td>10 year</td>
</tr>
</tbody></table>

<p>For example, converting <code>AirPassengers</code> to a data frame returns:</p>

<pre><code class="r">head(ts_df(AirPassengers))
#&gt;         time value
#&gt; 1 1949-01-01   112
#&gt; 2 1949-02-01   118
#&gt; 3 1949-03-01   132
#&gt; 4 1949-04-01   129
#&gt; 5 1949-05-01   121
#&gt; 6 1949-06-01   135
</code></pre>

<p>Heuristic conversion works both ways, so we can get back to the original <code>&quot;ts&quot;</code>
object:</p>

<pre><code class="r">all.equal(ts_ts(ts_df(AirPassengers)), AirPassengers)
#&gt; [1] TRUE
</code></pre>

<h2>Exact time conversion</h2>

<p>For non standard frequencies, e.g. 260, of <code>EuStockMarkets</code>, tsbox uses  <strong>exact
time conversion</strong>. The year is divided into 260 equispaced units, each somewhat
longer than a day. The time stamp of a period will be an exact point in time (of
class <code>&quot;POSIXct&quot;</code>).</p>

<pre><code class="r">head(ts_df(EuStockMarkets))
#&gt;    id                time   value
#&gt; 1 DAX 1991-07-01 03:18:27 1628.75
#&gt; 2 DAX 1991-07-02 13:01:32 1613.63
#&gt; 3 DAX 1991-07-03 22:44:38 1606.51
#&gt; 4 DAX 1991-07-05 08:27:43 1621.04
#&gt; 5 DAX 1991-07-06 18:10:48 1618.16
#&gt; 6 DAX 1991-07-08 03:53:53 1610.61
</code></pre>

<p>Higher frequencies, such as days, hours, minutes or seconds, are naturally
equispaced, and exact time conversion is used as well.</p>

<p>Exact time conversion is generally reversible:</p>

<pre><code class="r">all.equal(ts_ts(ts_df(EuStockMarkets)), EuStockMarkets)
#&gt; [1] TRUE
</code></pre>

<p>However, for high frequencies, rounding errors can lead to unavoidable small
differences when going from data frame to <code>&quot;ts&quot;</code> and back.</p>

<p>Conversion does not work reliably if the frequency higher than one second. For
these ultra high frequencies, tsbox is not tested and may not work as expected.</p>

<h2>Regularization</h2>

<p>In data frames or <code>&quot;xts&quot;</code> objects, missing values are generally omitted. These
omitted missing values are called implicit, as opposite to explicit <code>NA</code> values.
The function <code>ts_regular</code> allows the user to <em>regularize</em> a series, by making
implicit missing values explicit.</p>

<p>When regularizing, <code>ts_regular</code> analyzes the differences in the time stamp for
known frequencies. If it detects any, it builds a regular sequence based on the
highest known frequency, and tries to match the time stamps to the regular
series. The result is a data frame or <code>&quot;xts&quot;</code> object with explicit missing
values. Regularization is automatically done when an object is converted to a
<code>&quot;ts&quot;</code> object.</p>

<p>For example, the following time series contains an implicit <code>NA</code> value in
February 1974:</p>

<pre><code class="r">df &lt;- ts_df(fdeaths)[-2,]
head(df)
#&gt;         time value
#&gt; 1 1974-01-01   901
#&gt; 3 1974-03-01   827
#&gt; 4 1974-04-01   677
#&gt; 5 1974-05-01   522
#&gt; 6 1974-06-01   406
#&gt; 7 1974-07-01   441
</code></pre>

<p><code>ts_regular</code> can be used to turn it into a explicit <code>NA</code>:</p>

<pre><code class="r">head(ts_regular(df))
#&gt;         time value
#&gt; 1 1974-01-01   901
#&gt; 2 1974-02-01    NA
#&gt; 3 1974-03-01   827
#&gt; 4 1974-04-01   677
#&gt; 5 1974-05-01   522
#&gt; 6 1974-06-01   406
</code></pre>

<p>Regularization can be done for all frequencies that are suited for heuristic
conversion, as listed above. In addition to these frequencies, the following
higher frequencies are detected and regularized as well:</p>

<table><thead>
<tr>
<th><code>ts</code>-frequency</th>
<th>time difference</th>
</tr>
</thead><tbody>
<tr>
<td>31556952</td>
<td>1 sec</td>
</tr>
<tr>
<td>15778476</td>
<td>2 sec</td>
</tr>
<tr>
<td>6311390</td>
<td>5 sec</td>
</tr>
<tr>
<td>3155695</td>
<td>10 sec</td>
</tr>
<tr>
<td>2103797</td>
<td>15 sec</td>
</tr>
<tr>
<td>1577848</td>
<td>20 sec</td>
</tr>
<tr>
<td>1051898</td>
<td>30 sec</td>
</tr>
<tr>
<td>525949.2</td>
<td>1 min</td>
</tr>
<tr>
<td>262974.6</td>
<td>2 min</td>
</tr>
<tr>
<td>105189.8</td>
<td>5 min</td>
</tr>
<tr>
<td>52594.92</td>
<td>10 min</td>
</tr>
<tr>
<td>35063.28</td>
<td>15 min</td>
</tr>
<tr>
<td>26297.46</td>
<td>20 min</td>
</tr>
<tr>
<td>17531.64</td>
<td>30 min</td>
</tr>
<tr>
<td>8765.82</td>
<td>1 hour</td>
</tr>
<tr>
<td>4382.91</td>
<td>2 hour</td>
</tr>
<tr>
<td>2921.94</td>
<td>3 hour</td>
</tr>
<tr>
<td>2191.455</td>
<td>4 hour</td>
</tr>
<tr>
<td>1460.97</td>
<td>6 hour</td>
</tr>
<tr>
<td>730.485</td>
<td>12 hour</td>
</tr>
<tr>
<td>365.2425</td>
<td>1 day</td>
</tr>
</tbody></table>

</body>

</html>
